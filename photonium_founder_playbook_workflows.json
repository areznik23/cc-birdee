{
  "timestamp": "2025-07-21T21:27:33.012721",
  "workflows": {
    "0": {
      "workflow": "Automated Optical Design Agent",
      "pattern": "Adam keeps asking Claude to turn an informal chat about an optical sub-system (beam expander, interferometer, fibre coupling, etc.) into a single agent that: 1) figures out the right web/database searches, 2) pulls component data, 3) runs first-order Gaussian-optics checks, and 4) emits a clean JSON design spec the rest of Photonium can consume. He wants this in one self-contained tool file so that even with limited coding experience he can iterate on new designs fast.",
      "template": "############  PHOTONIUM ONE-SHOT AGENT  ############\n# Copy-paste this whole prompt into Claude Code and run once.            \n# Claude will generate a single Python file named  photonium_agent.py    \n# that automates: research \u2192 design \u2192 validate \u2192 JSON export             \n# for typical optical modules (beam expanders, interferometers, fibre    \n# couplers, etc.).                                                       \n#------------------------------------------------------------------------\n# HIGH-LEVEL REQUIREMENTS (EDIT BEFORE RUNNING)                          \nTARGET_SYSTEM = \"3\u00d7 Galilean beam expander for 780 nm, input beam 2 mm 1/e\u00b2, <1 mrad divergence, off-the-shelf optics only\"  # natural-language spec\n\n# OPTIONAL CONSTRAINTS                                                   \nMAX_BUDGET_USD   = 500    # None for unlimited\nCAD_EXPORT       = True   # also write STEP/OBJ placeholders\nTEST_WITH_RAYOPT = True   # run quick paraxial ray-trace for validation\n\n#------------------------------------------------------------------------\n# AGENT DESIGN SPECIFICATION                                             \n# 1. RESEARCH:                                                            \n#    \u2022 Determine key search queries (design notes, calc formulas, parts)  \n#    \u2022 Use browser.search/open for web + component catalogues             \n# 2. DESIGN:                                                              \n#    \u2022 Synthesize optical layout (lenses/spacings)                        \n#    \u2022 Pull real part numbers + specs from Thorlabs/Edmund                \n# 3. VALIDATE:                                                            \n#    \u2022 Gaussian propagation, ABCD matrices, diffraction limits            \n#    \u2022 Budget, mechanical clearances                                      \n# 4. OUTPUT:                                                              \n#    \u2022 Clean JSON \u2192 design.json                                           \n#    \u2022 Human summary (markdown)                                           \n#    \u2022 (opt) STEP stubs + Unity-ready asset list                          \n#------------------------------------------------------------------------\n# WHEN YOU RUN THIS PROMPT, CLAUDE SHOULD RETURN ONLY THE CODE FILE       \n# CONTENTS FOR  photonium_agent.py  (no extra commentary).                \n##########################################################################\n\n\"\"\"python\n\"\"\"  # <\u2014 Claude will overwrite this line with the full source code\n",
      "time_saved": "4-6 hours \u2192 30 minutes",
      "customer_impact": "Speeds up delivery of validated optical layouts so quantum-computing and biotech clients receive working prototypes days faster, letting Photonium close deals and iterate hardware with minimal manual engineering."
    },
    "1": {
      "workflow": "Beam Expander Design Pipeline",
      "pattern": "Adam keeps trying to chain together catalog look-ups, Gaussian/ABCD calculations, and CAD script generation so he can go from a desired expansion ratio to a fully validated two-lens beam-expander design in one shot. He wants Claude Code to act as an orchestrator that searches Thorlabs/Edmund parts, computes spacings, validates the propagation, and spits out a JSON spec plus Zemax & CAD files automatically.",
      "template": "SYSTEM: You are Photonium\u2019s Optical Design Agent.  \nGOAL: Starting from a few user-supplied numbers, deliver a COMPLETE two-lens beam-expander design (Keplerian or Galilean) that is manufacturable, validated, and ready for import into Zemax/Unity/CAD.  \nRETURN a single JSON object with the keys exactly as specified in STEP 8.  \nINTERNET is OFF\u2014simulate vendor catalog look-ups from Thorlabs & Edmund Optics 2023 data.  \nUse only Python 3.11 in code blocks.  \nKeep explanations inside code comments; outside the JSON, output nothing.  \n\nUSER INPUTS  (replace <> before running):\n```\ndesired_expansion_ratio = <e.g. 5.0>          # >1  \u21d2 Keplerian; 0\u20131 \u21d2 Galilean\ninput_beam_diameter_mm = <e.g. 2.0>\nwavelength_nm            = <e.g. 780>\navailable_length_mm      = <e.g. 150>         # mechanical envelope\nallowance_percent        = <e.g. 10>          # alignment/spacing tolerance\npreferred_vendors        = [\"Thorlabs\", \"Edmund\"]\nexport_formats           = [\"json\", \"zemax\", \"step\", \"unity\"]\n```\n\nSTEP-BY-STEP PROCEDURE\n1. Decide Galilean vs. Keplerian from desired_expansion_ratio.  \n2. Compute ideal focal lengths f1 & f2 and separation d using ABCD matrices.\n   \u2022 Keplerian:  f2 / f1 = desired_expansion_ratio, d \u2248 f1 + f2.  \n   \u2022 Galilean:  f2 / |f1| = desired_expansion_ratio, d \u2248 f2 \u2212 |f1|.  \n3. Pull candidate lenses that meet focal length \u00b15 %, diameter \u2265 input_beam_diameter\u00d71.5, and wavelength range.\n4. Rank lens pairs by (a) RMS spot size @ input beam, (b) cost, (c) outer diameter fit in available_length_mm.\n5. Pick best pair; recompute exact separation that minimizes divergence using Gaussian beam propagation.  \n6. Validate design: output waist, divergence, Rayleigh range, tolerance stack-up \u00b1allowance_percent. Fail if M\u00b2>1.2.\n7. Create deliverables:\n   a. design_spec JSON (lens SKUs, positions, spacings, mounts)  \n   b. bom list with cost & URLs  \n   c. zemax_script: Python (ZOS-API) that builds the system & runs POP  \n   d. cad_step_instructions: text describing how to place STEP files & coordinate frames  \n   e. unity_scene_json: minimal GLTF-compatible object list with transforms  \n   f. test_script: stand-alone Python using rayoptics to verify waist & expansion  \n8. RETURN EXACTLY:\n```json\n{\n  \"design_spec\": {\u2026},\n  \"bom\": [ \u2026 ],\n  \"zemax_script\": \"\"\"python\\n# code here\\n\"\"\",\n  \"cad_step_instructions\": \"\u2026\",\n  \"unity_scene_json\": { \u2026 },\n  \"test_script\": \"\"\"python\\n# code here\\n\"\"\"\n}\n```\nDO NOT output anything else.\n\nBEGIN:",
      "time_saved": "6-8 hours \u2192 20 minutes",
      "customer_impact": "Quantum, biotech, and LiDAR teams receive a turnkey beam-expander module\u2014including validated physics, procurement SKUs, and CAD assets\u2014in a single request, letting them integrate new optical paths days faster and iterate hardware designs before lab time fills up."
    },
    "2": {
      "workflow": "Optical Component Sourcing Pipeline",
      "pattern": "Adam keeps trying to wire up Playwright MCP so the agent can browse vendor websites, scrape lens / mirror specs, run quick Gaussian-beam checks, then return a ready-to-order parts list as JSON. He wants the entire research\u2192calc\u2192scrape\u2192validate\u2192export loop handled in one shot so he can drop the JSON into Photonium without writing glue code.",
      "template": "########################  PHOTONIUM ONE-SHOT COMPONENT SOURCING  ########################\n# Copy-paste this whole block into Claude Code. Edit only the INPUT section.\n# Claude will: derive optical specs \u2192 launch mcp__playwright browser \u2192 scrape vendor parts  \n# \u2192 rank & validate with physics calcs \u2192 return JSON + CAD/Unity helpers.\n###########################################################################################\n\nSYSTEM:\nYou are Photonium\u2019s autonomous optical-design agent.  \nYou have access to Python (for calculations & data wrangling) and the tool \"mcp__playwright\" (for headless browsing & scraping).  \nWork safely (respect robots.txt, 5-min scrape cap per vendor).  \nFinal answer MUST contain:  \n1. \"human_report\" (concise summary)  \n2. \"component_list.json\" (array of objects)  \n3. \"design_validation.json\" (system-level metrics)  \n4. \"cad_download.sh\" (bash)  \n5. \"unity_import.cs\" (C# stub)  \nEverything wrapped in one Markdown fenced block the user can save.\n\n###########################################################################################\nINPUT:\n{\n  \"design_goal\": \"780 nm single-mode fiber collimator\",\n  \"wavelength_nm\": 780,\n  \"input_beam_waist_mm\": 0.55,\n  \"target_waist_mm\": 2.0,\n  \"M2_max\": 1.2,\n  \"vendors\": [\"Thorlabs\", \"Edmund Optics\"],\n  \"max_budget_usd\": 1500,\n  \"cad_format\": \"STEP\"\n}\n###########################################################################################\n\nTASKS (execute sequentially):\n1. Translate design_goal + beam parameters into required component specifications using Gaussian-beam & ABCD matrix theory (Python). Derive lens focal length, diameter, AR coating range, etc.\n2. For each vendor in INPUT:\n    a. Launch browser via mcp__playwright.\n    b. Search site for parts matching specs (keywords + filters).\n    c. Scrape: part_number, price, stock, focal_length, diameter, coating_range, CAD link, spec PDF.\n    d. Store in pandas DataFrame.\n3. Filter & rank components: discard out-of-spec or over-budget items; rank by optical fit, lead-time, price.\n4. Build candidate systems (single-lens or multi-lens if needed). Use Python to simulate beam propagation and compute final waist, divergence, throughput, tolerance margins.\n5. Select top-scoring system under budget and within M\u00b2 target.\n6. Generate component_list.json (fields: part_number, vendor, price_usd, focal_length_mm, diameter_mm, coating, cad_url, spec_url, score).\n7. Generate design_validation.json (calculated waist_mm, M2, transmission_est, alignment_tolerance_mm, safety_margin_dB).\n8. Produce cad_download.sh that wget/curl\u2019s each cad_url into ./cad/ in requested format.\n9. Produce unity_import.cs stub that loads the STEP files into Unity (requires PiXYZ or similar) and places them with correct transforms.\n10. Output human_report summarizing why the chosen components meet specs and next steps.\n\nBEGIN EXECUTION NOW.",
      "time_saved": "6-8 hours \u2192 30 minutes",
      "customer_impact": "Cuts a full business day of part hunting and manual spec checking down to half an hour, letting Photonium deliver validated, order-ready optical BOMs to quantum and biotech customers before their competitors even start searching."
    },
    "3": {
      "workflow": "Interferometer Design Validation",
      "pattern": "Adam keeps trying to build a single Claude-driven agent that can take high-level interferometer performance targets, automatically pick an appropriate architecture (Michelson, Mach-Zehnder, Sagnac), pull real parts from vendor catalogs, run Gaussian-beam and path-length calculations to predict fringe contrast, and then unit-test those predictions so the whole sequence can be re-run in CI without manual patch-ups.",
      "template": "TITLE:  End-to-End Interferometer Design & Validation Agent\nROLE:   Claude Code \u2013 produce Python + JSON outputs, ready for CI. No band-aid \"mock\" fixes; if a test fails, troubleshoot until physics and code both pass.\n\nUSER INPUT SECTION  (copy-paste and fill):\n```json\n{\n  \"application\": \"(e.g. Quantum sensing)\",\n  \"wavelength_nm\": 780,\n  \"required_contrast\": 0.95,\n  \"max_footprint_mm\": [200, 150],          // [L, W]\n  \"path_difference_tolerance_mm\": 0.05,\n  \"beam_diameter_mm\": 2.0,\n  \"budget_usd\": 5000,\n  \"preferred_architectures\": [\"Michelson\", \"Mach-Zehnder\"],\n  \"vendors\": [\"Thorlabs\", \"Edmund Optics\"],\n  \"cad_export\": true                      // true = export STEP + JSON\n}\n```\n\nAGENT TASK LIST (execute sequentially):\n1. Research\n   a. Pick best interferometer architecture for the input.\n   b. Query vendor CSV/JSON catalogs (use provided Thorlabs + Edmund endpoints) for beamsplitters, mirrors, mounts, and fiber couplers that meet \u03bb, damage threshold, ROHS.\n   c. Return top-3 BOM options sorted by cost.\n\n2. Physics Calculations\n   a. Model Gaussian beam propagation (use `scipy`, `numpy`).\n   b. Compute path-length difference, phase error, expected fringe visibility.\n   c. Run Monte-Carlo tolerance on mirror tilt (\u00b10.1 mrad) & BS thickness.\n\n3. Design Synthesis\n   a. Choose final parts list.\n   b. Auto-layout optics on 2-D breadboard grid within footprint.\n   c. Generate STEP assembly tree (if `cad_export==true`) using `cadquery`.\n\n4. Validation & Testing\n   a. Create pytest suite:\n      \u2022 `test_contrast()` asserts computed contrast \u2265 required.\n      \u2022 `test_footprint()` checks bounding box.\n      \u2022 `test_budget()` ensures total cost \u2264 budget.\n   b. Run tests; if any fail, iterate design (no mocks or skips!).\n\n5. Output\n   Produce a single JSON report:\n   ```json\n   {\n     \"architecture\": \"Michelson\",\n     \"contrast_predicted\": 0.97,\n     \"path_length_mm\": 150.02,\n     \"parts\": [{\"sku\":\"BS013\",\"vendor\":\"Thorlabs\",...}],\n     \"total_cost_usd\": 3870,\n     \"cad_step_path\": \"./interferometer.step\",\n     \"tests_passed\": true\n   }\n   ```\n   and zip with `design_report.md`, `bom.csv`, `cad/`.\n\nCODE CONSTRAINTS:\n\u2022 Everything in one Python file <300 LOC plus pytest folder.\n\u2022 Comment every physics formula.\n\u2022 No undocumented globals.\n\u2022 Use type hints.\n\nSTART NOW: read the JSON above, then emit the full Python implementation, pytest files, the filled design JSON, and a short next-steps note. When tests pass, declare DONE.",
      "time_saved": "6-8 hours \u2192 25 minutes",
      "customer_impact": "Photonium can deliver interferometer subsystems for quantum sensors and biotech instruments within a single work session, letting customers iterate optical architectures same-day instead of waiting for week-long manual design cycles."
    }
  }
}